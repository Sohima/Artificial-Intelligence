# -*- coding: utf-8 -*-
"""sudoku_AI.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LUMQkkJQf_Yq8XVYlqe6zBeCMBZuf5av

# Sudoku Constraint Satisfaction Problem Solver with various AI Agents.

In this project, an AI Agent has been created which utilizes backtracking search and Constraint Satisfaction Problem heuristics to solve Sudoku puzzles of variable size.

A sudoku board is comprised of a grid of size N, with each grid comprised of p rows and q columns. The agent will attempt backtracking search to fill the grid cells so that each row, column, and grid cell has unique numbers.

This is a program that solves sudoku puzzles using artificial intelligence concepts. This program treats the puzzle as a Constraint Satisfaction Problem (CSP). Each of the squares in the puzzle is treated as a separate variable, with domain 1-9. The constraints to the problem are that each row, column, and 3x3 sub-square must contain the numbers 1 through 9 with no repeats.

The way this problem is solved is using the Backtracking Search algorithm. This is a variation on Depth First Search (DFS) that eliminates states that are invalid before they are expanded to completion in order to reduce the number of expanded nodes and therefore increase performance. Also the different variables are expanded in an order such that it will limit the number of nodes that have to be expanded.

In order to eliminate as many contradictory possible values as possible, as quickly as possible, this CSP implements the Arc-Consistency: Constraint Propagation algorithm, or AC-3. Whenever a value is updated it will form a queue of arcs, which are pairs of positions that are affected by the updated value. Then it will go through each arc and remove values from the domain of the tail of each arc if they contradict. If a domain is altered it will add all of the arcs affected by this domain change to the queue and will repeat until the queue is empty.

The possible values of each variable are kept track of in the Sudoku class instances and when it comes time to decide which variable to expand next in the search, it will use the given heuristic to determine which variable to expand next. The heuristics that are implemented in this program are as follows:

The trivial heuristic.
This heuristic returns the first variable that has not yet been expanded.
This does not help performance in any way.
The Minimum Remaining Values (MRV) heuristic.
This heuristic chooses the node with the least amount of possible values remaining.
This helps reduce the total number of nodes expanded because there are fewer branches to the search tree this way, and it is more likely to pick the correct value for the given variable.
A state is discarded if it is found to be in violation of any of the constraints of the sudoku puzzle. If there is more than one of the same number in any given row, column, or 3x3 sub-square then that state is discarded so that it does not have to keep being expanded until it is complete to find out that it is incorrect. In addition if a variable's domain is empty, then that state is discarded because there is no possible value that can be entered there such that the state maintains validity.
"""

from time import time
import copy
class SodukuSolver:
    def __init__(self,dim,fileDir):
        self.dim = dim
        self.expandedNodes = 0
        with open(fileDir) as f:
	        content = f.readlines()
	        self.board = [list(x.strip()) for x in content]
        self.rv = self.getRemainingValues()

    def __str__(self):
        string = ''
        for row in self.board:
            for x in row:
                string += x+" "
            string+='\n'
        string+= "Nodes expanded: {}".format(self.expandedNodes)
        return string

    def getDomainLength(self,lst):
        if 'x' in lst or lst == []:
            return 10
        else:
            return len(lst)

    def isSafe(self,row,col,choice):
        choiceStr = str(choice)
        for i in range(self.dim):
            if self.board[row][i] == choiceStr or self.board[i][col] ==choiceStr:
                return False

        boxR = row - (row % 3)
        boxV = col - (col % 3)
        for i in range(3):
            for j in range(3):
                if self.board[boxR + i][boxV + j] == choiceStr:
                    return False
        return True

    def getNextLocation(self):
        for i in range(self.dim):
            for j in range(self.dim):
                if self.board[i][j] == '0':
                    return (i,j)
        return (-1,-1)

    def getNextLoctaionMRVRow(self):
        minRowCount = 10
        rowIndex = 9
        colIndex = 9
        minRow = []
        for i in range(self.dim):
            count = 0
            if '0' not in self.board[i]:
                continue
            for j in range(self.dim):
                if self.board[i][j]=='0':
                    count+=1
            if minRowCount > count:
                minRowCount = count
                minRow = self.board[i]
                rowIndex = i
        if minRow == []:
            return (-1,-1)
        for i in range(self.dim):
            if minRow[i] == '0':
                colIndex = i
                break
        return (rowIndex,colIndex)

    def getNextMRVRowCol(self):
        rvMap = list(map(self.getDomainLength,self.rv))
        minimum = min(rvMap)
        if minimum == 10:
            return (-1,-1)
        index = rvMap.index(minimum)
        return(index // 9, index % 9)


    def getNextDegreeHeuristic(self):
        maxRowCount = -1
        rowIndex = 9
        colIndex = 9
        maxRow = []
        for i in range(self.dim):
            count = 0
            if '0' not in self.board[i]:
                continue
            for j in range(self.dim):
                if self.board[i][j]=='0':
                    count+=1
            if maxRowCount < count:
                maxRowCount = count
                maxRow = self.board[i]
                rowIndex = i
        if maxRow == []:
            return (-1,-1)
        else:
            maxColCount = -1
            for i in range(self.dim):
                count = 0
                if maxRow[i] == '0':
                    for j in range(self.dim):
                        if self.board[j][i]=='0':
                            count+=1
                    if count > maxColCount:
                        maxColCount = count
                        colIndex = i
            return(rowIndex,colIndex)

    def removeValue(self,row,col,value,RV):
        RV[row*9 +col] = ['0']
        for lst in RV[row*9:row*9+9]:
            if value in lst:
                lst.remove(value)
        for i in range(self.dim):
            if value in RV[i*9+col]:
                RV[i*9+col].remove(value)
        boxRow = int(row/3)
        boxCol = int(col/3)
        for i in range(3):
            for j in range(3):
                if value in RV[(boxRow*3+i)*9 + j + boxCol*3]:
                    RV[(boxRow*3+i)*9 + j + boxCol*3].remove(value)

        #
        RV[row*9 + col] = [value]
        return RV

    def getDomain(self,row,col):
        RVCell = [str(i) for i in range(1 ,self.dim + 1)]
        for i in range(self.dim):
            if self.board[row][i] != '0':
                if self.board[row][i] in RVCell:
                    RVCell.remove(self.board[row][i])

        for i in range(self.dim):
            if self.board[i][col] != '0':
                if self.board[i][col] in RVCell:
                    RVCell.remove(self.board[i][col])

        boxRow = row - row%3
        boxCol = col - col%3
        for i in range(3):
            for j in range(3):
                if self.board[boxRow+i][boxCol+j]!=0:
                    if self.board[boxRow+i][boxCol+j] in RVCell:
                        RVCell.remove(self.board[boxRow+i][boxCol+j])
        return RVCell

    def getRemainingValues(self):
        RV=[]
        for row in range(self.dim):
            for col in range(self.dim):
                if self.board[row][col] != '0':
                    RV.append(['x'])
                else:
                    RV.append(self.getDomain(row,col))
        return RV

    def getChoice(self,lst):
        count = [0 for i in range(len(lst))]
        for i in range(len(lst)):
            c = 0
            for j in range(self.dim):
                c += self.board[j].count(lst[i])
            count[i] = c

        return lst[count.index(min(count))]

    def isConsistent(self,row,col,value,rv):
        board = self.board[:][:]
        board[row][col] = value
        RV = []
        for row in range(self.dim):
            for col in range(self.dim):
                if self.board[row][col] != '0':
                    digit = board[row][col]
                    RV.append([digit])
                else:
                    RVCell = [str(i) for i in range(1 ,self.dim + 1)]
                    for i in range(self.dim):
                        if board[row][i] != '0':
                            if board[row][i] in RVCell:
                                RVCell.remove(board[row][i])

                    for i in range(self.dim):
                        if board[i][col] != '0':
                            if board[i][col] in RVCell:
                                RVCell.remove(board[i][col])

                    boxRow = row - row%3
                    boxCol = col - col%3
                    for i in range(3):
                        for j in range(3):
                            if board[boxRow+i][boxCol+j]!=0:
                                if board[boxRow+i][boxCol+j] in RVCell:
                                    RVCell.remove(board[boxRow+i][boxCol+j])
                    if RVCell == []:
                        return False
        return True
    '''Solving methods'''
    def solveSimpleBackTracking(self):
        location = self.getNextLocation()
        if location[0] == -1:
            return True
        else:
            self.expandedNodes += 1
            for choice in range(1,self.dim+1):
                if self.isSafe(location[0],location[1],choice):
                    self.board[location[0]][location[1]] = str(choice)
                    if self.solveSimpleBackTracking():
                        return True
                    self.board[location[0]][location[1]] = '0'
            return False

    def solveCSP(self,locationFunction):
        location = locationFunction()

        if location[0] == -1:
            return True
        else:
            self.expandedNodes+=1
            for choice in range(1,self.dim+1):
                if self.isSafe(location[0],location[1],choice):
                    self.board[location[0]][location[1]] = str(choice)
                    if self.solveCSP(locationFunction):
                        return True
                    self.board[location[0]][location[1]] = '0'
            return False

    def isEmptyDomainProduced(self,row,col,choice):
        element = self.rv.pop(row*9 + col)
        if [] in self.rv:
            self.rv.insert(row*9+col,element)
            return True
        else:
            self.rv.insert(row*9+col,element)
            return False
                

    def solveCSPFH(self):
        location = self.getNextMRVRowCol()
        if location[0] == -1:
            return True
        else:
            self.expandedNodes+=1
            # rv = self.getRemainingValues()
            row = location[0]
            col = location[1]
            for choice in self.rv[row*9+col]:
                choice_str = str(choice)
                self.board[row][col] =  choice_str
                cpy = copy.deepcopy(self.rv) 
                self.rv = self.getRemainingValues()
                
                if not self.isEmptyDomainProduced(row,col,choice_str):
                    if self.solveCSPFH():
                        return True
                self.board[row][col] = '0'
                self.rv = cpy

            return False



file = 's2'
s = SodukuSolver(9,'testCases/{}.txt'.format(file))
start = time()
# s.solveCSP(s.getNextDegreeHeuristic)
# s.solveSimpleBackTracking()
s.solveCSPFH()
end = time()
print(s)
print("Time Elapsed:{}".format(end-start))